<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hopscotch-map: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">hopscotch-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">hopscotch-map Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/Tessil/hopscotch-map"></a> <a href="https://ci.appveyor.com/project/Tessil/hopscotch-map/branch/master"></a></p>
<h2>A C++ implementation of a fast hash map and hash set using hopscotch hashing</h2>
<p>The hopscotch-map library is a C++ implementation of a fast hash map and hash set using open-addressing and hopscotch hashing to resolve collisions. It is a cache-friendly data structure offering better performances than <code>std::unordered_map</code> in most cases and is closely similar to <code>google::dense_hash_map</code> while using less memory and providing more functionalities.</p>
<p>The library provides the following main classes: <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code>, <code><a class="el" href="classtsl_1_1hopscotch__set.html">tsl::hopscotch_set</a></code>, <code><a class="el" href="namespacetsl.html#a2845f6f2658f94b80cebec7e138d9c25">tsl::hopscotch_pg_map</a></code> and <code><a class="el" href="namespacetsl.html#afe88acbc8c6f26efda106ceb0d529631">tsl::hopscotch_pg_set</a></code>. The first two are faster and use a power of two growth policy, the last two use a prime growth policy instead and are able to cope better with a poor hash function. Use the prime version if there is a chance of repeating patterns in the lower bits of your hash (e.g. you are storing pointers with an identity hash function). See <a href="#growth-policy">GrowthPolicy</a> for details.</p>
<p>In addition to these classes the library also provides <code><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a></code>, <code><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a></code>, <code><a class="el" href="namespacetsl.html#a48320fc12891c29ed40544fd4c0b1bd2">tsl::bhopscotch_pg_map</a></code> and <code><a class="el" href="namespacetsl.html#a4e616c9e5079be6bdb39584f05a9679c">tsl::bhopscotch_pg_set</a></code>. These classes have an additional requirement for the key, it must be <code>LessThanComparable</code>, but they provide a better asymptotic upper bound, see <a href="#deny-of-service-dos-attack">details</a> in example. Nonetheless if you don't have specific requirements (risk of hash DoS attacks), <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code> and <code><a class="el" href="classtsl_1_1hopscotch__set.html">tsl::hopscotch_set</a></code> should be sufficient in most cases and should be your default pick as they perform better in general.</p>
<p>An overview of hopscotch hashing and some implementation details can be found <a href="https://tessil.github.io/2016/08/29/hopscotch-hashing.html">here</a>.</p>
<p>A <b>benchmark</b> of <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code> against other hash maps may be found <a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">here</a>. This page also gives some advices on which hash table structure you should try for your use case (useful if you are a bit lost with the multiple hash tables implementations in the <code>tsl</code> namespace).</p>
<h3>Key features</h3>
<ul>
<li>Header-only library, just add the <a href="include/">include</a> directory to your include path and you are ready to go. If you use CMake, you can also use the <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code> exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a>.</li>
<li>Fast hash table, see <a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">benchmark</a> for some numbers.</li>
<li>Support for move-only and non-default constructible key/value.</li>
<li>Support for heterogeneous lookups allowing the usage of <code>find</code> with a type different than <code>Key</code> (e.g. if you have a map that uses <code>std::unique_ptr&lt;foo&gt;</code> as key, you can use a <code>foo*</code> or a <code>std::uintptr_t</code> as key parameter to <code>find</code> without constructing a <code>std::unique_ptr&lt;foo&gt;</code>, see <a href="#heterogeneous-lookups">example</a>).</li>
<li>No need to reserve any sentinel value from the keys.</li>
<li>Possibility to store the hash value on insert for faster rehash and lookup if the hash or the key equal functions are expensive to compute (see the <a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hopscotch__map.html#details">StoreHash</a> template parameter).</li>
<li>If the hash is known before a lookup, it is possible to pass it as parameter to speed-up the lookup (see <code>precalculated_hash</code> parameter in <a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hopscotch__map.html#a74d83c67c50bc8385bb11f78142eaa86">API</a>).</li>
<li>The <code><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a></code> and <code><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a></code> provide a worst-case of O(log n) on lookups and deletions making these classes resistant to hash table Deny of Service (DoS) attacks (see <a href="#deny-of-service-dos-attack">details</a> in example).</li>
<li>API closely similar to <code>std::unordered_map</code> and <code>std::unordered_set</code>.</li>
</ul>
<h3>Differences compare to <code>std::unordered_map</code></h3>
<p><code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code> tries to have an interface similar to <code>std::unordered_map</code>, but some differences exist.</p><ul>
<li>Iterator invalidation on insert doesn't behave in the same way. In general any operation modifying the hash table, except <code>erase</code>, invalidate all the iterators (see <a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hopscotch__map.html#details">API</a> for details).</li>
<li>References and pointers to keys or values in the map are invalidated in the same way as iterators to these keys-values on insert.</li>
<li>For iterators, <code>operator*()</code> and <code>operator-&gt;()</code> return a reference and a pointer to <code>const std::pair&lt;Key, T&gt;</code> instead of <code>std::pair&lt;const Key, T&gt;</code>, making the value <code>T</code> not modifiable. To modify the value you have to call the <code>value()</code> method of the iterator to get a mutable reference. Example: <div class="fragment"><div class="line">{c++}</div><div class="line">tsl::hopscotch_map&lt;int, int&gt; map = {{1, 1}, {2, 1}, {3, 1}};</div><div class="line">for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">    //it-&gt;second = 2; // Illegal</div><div class="line">    it.value() = 2; // Ok</div><div class="line">}</div></div><!-- fragment --></li>
<li>Move-only types must have a nothrow move constructor (with open addressing, it is not possible to keep the strong exception guarantee on rehash if the move constructor may throw).</li>
<li>No support for some buckets related methods (like <code>bucket_size</code>, <code>bucket</code>, ...).</li>
</ul>
<p>These differences also apply between <code>std::unordered_set</code> and <code><a class="el" href="classtsl_1_1hopscotch__set.html">tsl::hopscotch_set</a></code>.</p>
<p>Thread-safety and exceptions guarantees are the same as <code>std::unordered_map/set</code> (i.e. possible to have multiple readers with no writer).</p>
<h3>Growth policy</h3>
<p>The library supports multiple growth policies through the <code>GrowthPolicy</code> template parameter. Three policies are provided by the library but you can easily implement your own if needed.</p>
<ul>
<li><b><a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hh_1_1power__of__two__growth__policy.html">tsl::hh::power_of_two_growth_policy.</a></b> Default policy used by <code>tsl::(b)hopscotch_map/set</code>. This policy keeps the size of the bucket array of the hash table to a power of two. This constraint allows the policy to avoid the usage of the slow modulo operation to map a hash to a bucket, instead of <code>hash % 2<sup>n</sup></code>, it uses <code>hash &amp; (2<sup>n</sup> - 1)</code> (see <a href="https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues">fast modulo</a>). Fast but this may cause a lot of collisions with a poor hash function as the modulo with a power of two only masks the most significant bits in the end.</li>
<li><b><a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hh_1_1prime__growth__policy.html">tsl::hh::prime_growth_policy.</a></b> Default policy used by <code>tsl::(b)hopscotch_pg_map/set</code>. The policy keeps the size of the bucket array of the hash table to a prime number. When mapping a hash to a bucket, using a prime number as modulo will result in a better distribution of the hashes across the buckets even with a poor hash function. To allow the compiler to optimize the modulo operation, the policy use a lookup table with constant primes modulos (see <a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hh_1_1prime__growth__policy.html#details">API</a> for details). Slower than <code><a class="el" href="classtsl_1_1hh_1_1power__of__two__growth__policy.html">tsl::hh::power_of_two_growth_policy</a></code> but more secure.</li>
<li><b><a href="https://tessil.github.io/hopscotch-map/classtsl_1_1hh_1_1mod__growth__policy.html">tsl::hh::mod_growth_policy.</a></b> The policy grows the map by a customizable growth factor passed in parameter. It then just use the modulo operator to map a hash to a bucket. Slower but more flexible.</li>
</ul>
<p>If you encounter poor performances check the <code>overflow_size()</code>, if it is not zero you may have a lot of hash collisions. Either change the hash function for something more uniform or try another growth policy (mainly <code><a class="el" href="classtsl_1_1hh_1_1prime__growth__policy.html">tsl::hh::prime_growth_policy</a></code>). Unfortunately it is sometimes difficult to guard yourself against collisions (e.g. DoS attack on the hash map). If needed, check also <code><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a>/set</code> which offer a worst-case scenario of O(log n) on lookups instead of O(n), see <a href="#deny-of-service-dos-attack">details</a> in example.</p>
<p>To implement your own policy, you have to implement the following interface.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">struct custom_policy {</div><div class="line">    // Called on hash table construction and rehash, min_bucket_count_in_out is the minimum buckets</div><div class="line">    // that the hash table needs. The policy can change it to a higher number of buckets if needed </div><div class="line">    // and the hash table will use this value as bucket count. If 0 bucket is asked, then the value</div><div class="line">    // must stay at 0.</div><div class="line">    explicit custom_policy(std::size_t&amp; min_bucket_count_in_out);</div><div class="line"></div><div class="line">    // Return the bucket [0, bucket_count()) to which the hash belongs. </div><div class="line">    // If bucket_count() is 0, it must always return 0.</div><div class="line">    std::size_t bucket_for_hash(std::size_t hash) const noexcept;</div><div class="line"></div><div class="line">    // Return the number of buckets that should be used on next growth</div><div class="line">    std::size_t next_bucket_count() const;</div><div class="line"></div><div class="line">    // Maximum number of buckets supported by the policy</div><div class="line">    std::size_t max_bucket_count() const;</div><div class="line"></div><div class="line">    // Reset the growth policy as if the policy was created with a bucket count of 0.</div><div class="line">    // After a clear, the policy must always return 0 when bucket_for_hash() is called.</div><div class="line">    void clear() noexcept;</div><div class="line">}</div></div><!-- fragment --> <h3>Installation</h3>
<p>To use hopscotch-map, just add the <a href="include/">include</a> directory to your include path. It is a <b>header-only</b> library.</p>
<p>If you use CMake, you can also use the <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code> exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a> with <code>target_link_libraries</code>. </p><div class="fragment"><div class="line"># Example where the hopscotch-map project is stored in a third-party directory</div><div class="line">add_subdirectory(third-party/hopscotch-map)</div><div class="line">target_link_libraries(your_target PRIVATE tsl::hopscotch_map)  </div></div><!-- fragment --><p>The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.</p>
<p>To run the tests you will need the Boost Test library and CMake.</p>
<div class="fragment"><div class="line">git clone https://github.com/Tessil/hopscotch-map.git</div><div class="line">cd hopscotch-map/tests</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">cmake --build .</div><div class="line">./tsl_hopscotch_map_tests </div></div><!-- fragment --><h3>Usage</h3>
<p>The API can be found <a href="https://tessil.github.io/hopscotch-map/">here</a>.</p>
<p>All methods are not documented yet, but they replicate the behaviour of the ones in <code>std::unordered_map</code> and <code>std::unordered_set</code>, except if specified otherwise.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;cstdint&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;tsl/hopscotch_map.h&gt;</div><div class="line">#include &lt;tsl/hopscotch_set.h&gt;</div><div class="line"></div><div class="line">int main() {</div><div class="line">    tsl::hopscotch_map&lt;std::string, int&gt; map = {{&quot;a&quot;, 1}, {&quot;b&quot;, 2}};</div><div class="line">    map[&quot;c&quot;] = 3;</div><div class="line">    map[&quot;d&quot;] = 4;</div><div class="line"></div><div class="line">    map.insert({&quot;e&quot;, 5});</div><div class="line">    map.erase(&quot;b&quot;);</div><div class="line"></div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        //it-&gt;second += 2; // Not valid.</div><div class="line">        it.value() += 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    // {d, 6} {a, 3} {e, 7} {c, 5}</div><div class="line">    for(const auto&amp; key_value : map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    if(map.find(&quot;a&quot;) != map.end()) {</div><div class="line">        std::cout &lt;&lt; &quot;Found \&quot;a\&quot;.&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    const std::size_t precalculated_hash = std::hash&lt;std::string&gt;()(&quot;a&quot;);</div><div class="line">    // If we already know the hash beforehand, we can pass it in parameter to speed-up lookups.</div><div class="line">    if(map.find(&quot;a&quot;, precalculated_hash) != map.end()) {</div><div class="line">        std::cout &lt;&lt; &quot;Found \&quot;a\&quot; with hash &quot; &lt;&lt; precalculated_hash &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    /*</div><div class="line">     * Calculating the hash and comparing two std::string may be slow. </div><div class="line">     * We can store the hash of each std::string in the hash map to make </div><div class="line">     * the inserts and lookups faster by setting StoreHash to true.</div><div class="line">     */ </div><div class="line">    tsl::hopscotch_map&lt;std::string, int, std::hash&lt;std::string&gt;, </div><div class="line">                       std::equal_to&lt;std::string&gt;,</div><div class="line">                       std::allocator&lt;std::pair&lt;std::string, int&gt;&gt;,</div><div class="line">                       30, true&gt; map2;</div><div class="line"></div><div class="line">    map2[&quot;a&quot;] = 1;</div><div class="line">    map2[&quot;b&quot;] = 2;</div><div class="line"></div><div class="line">    // {a, 1} {b, 2}</div><div class="line">    for(const auto&amp; key_value : map2) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tsl::hopscotch_set&lt;int&gt; set;</div><div class="line">    set.insert({1, 9, 0});</div><div class="line">    set.insert({2, -1, 9});</div><div class="line"></div><div class="line">    // {0} {1} {2} {9} {-1}</div><div class="line">    for(const auto&amp; key : set) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><h4>Heterogeneous lookups</h4>
<p>Heterogeneous overloads allow the usage of other types than <code>Key</code> for lookup and erase operations as long as the used types are hashable and comparable to <code>Key</code>.</p>
<p>To activate the heterogeneous overloads in <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a>/set</code>, the qualified-id <code>KeyEqual::is_transparent</code> must be valid. It works the same way as for <a href="http://en.cppreference.com/w/cpp/container/map/find"><code>std::map::find</code></a>. You can either use <a href="http://en.cppreference.com/w/cpp/utility/functional/equal_to_void"><code>std::equal_to&lt;&gt;</code></a> or define your own function object.</p>
<p>Both <code>KeyEqual</code> and <code>Hash</code> will need to be able to deal with the different types.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;tsl/hopscotch_map.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">struct employee {</div><div class="line">    employee(int id, std::string name) : m_id(id), m_name(std::move(name)) {</div><div class="line">    }</div><div class="line"></div><div class="line">    // Either we include the comparators in the class and we use `std::equal_to&lt;&gt;`...</div><div class="line">    friend bool operator==(const employee&amp; empl, int empl_id) {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(int empl_id, const employee&amp; empl) {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(const employee&amp; empl1, const employee&amp; empl2) {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    int m_id;</div><div class="line">    std::string m_name;</div><div class="line">};</div><div class="line"></div><div class="line">// ... or we implement a separate class to compare employees.</div><div class="line">struct equal_employee {</div><div class="line">    using is_transparent = void;</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl, int empl_id) const {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(int empl_id, const employee&amp; empl) const {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl1, const employee&amp; empl2) const {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">struct hash_employee {</div><div class="line">    std::size_t operator()(const employee&amp; empl) const {</div><div class="line">        return std::hash&lt;int&gt;()(empl.m_id);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::size_t operator()(int id) const {</div><div class="line">        return std::hash&lt;int&gt;()(id);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    // Use std::equal_to&lt;&gt; which will automatically deduce and forward the parameters</div><div class="line">    tsl::hopscotch_map&lt;employee, int, hash_employee, std::equal_to&lt;&gt;&gt; map; </div><div class="line">    map.insert({employee(1, &quot;John Doe&quot;), 2001});</div><div class="line">    map.insert({employee(2, &quot;Jane Doe&quot;), 2002});</div><div class="line">    map.insert({employee(3, &quot;John Smith&quot;), 2003});</div><div class="line"></div><div class="line">    // John Smith 2003</div><div class="line">    auto it = map.find(3);</div><div class="line">    if(it != map.end()) {</div><div class="line">        std::cout &lt;&lt; it-&gt;first.m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    map.erase(1);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // Use a custom KeyEqual which has an is_transparent member type</div><div class="line">    tsl::hopscotch_map&lt;employee, int, hash_employee, equal_employee&gt; map2;</div><div class="line">    map2.insert({employee(4, &quot;Johnny Doe&quot;), 2004});</div><div class="line"></div><div class="line">    // 2004</div><div class="line">    std::cout &lt;&lt; map2.at(4) &lt;&lt; std::endl;</div><div class="line">} </div></div><!-- fragment --><h4>Deny of Service (DoS) attack</h4>
<p>In addition to <code><a class="el" href="classtsl_1_1hopscotch__map.html">tsl::hopscotch_map</a></code> and <code><a class="el" href="classtsl_1_1hopscotch__set.html">tsl::hopscotch_set</a></code>, the library provides two more "secure" options: <code><a class="el" href="classtsl_1_1bhopscotch__map.html">tsl::bhopscotch_map</a></code> and <code><a class="el" href="classtsl_1_1bhopscotch__set.html">tsl::bhopscotch_set</a></code> (all with their <code>pg</code> counterpars).</p>
<p>These two additions have a worst-case asymptotic complexity of O(log n) for lookups and deletions and an amortized worst case of O(log n) for insertions (amortized due to the possibility of rehash which would be in O(n)). Even if the hash function maps all the elements to the same bucket, the O(log n) would still hold.</p>
<p>This provides a security against hash table Deny of Service (DoS) attacks.</p>
<p>To achieve this, the <em>secure</em> versions use a binary search tree for the overflown elements (see <a href="https://tessil.github.io/2016/08/29/hopscotch-hashing.html">implementation details</a>) and thus need the elements to be <code>LessThanComparable</code>. An additional <code>Compare</code> template parameter is needed.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;chrono&gt;</div><div class="line">#include &lt;cstdint&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;tsl/hopscotch_map.h&gt;</div><div class="line">#include &lt;tsl/bhopscotch_map.h&gt;</div><div class="line"></div><div class="line">/*</div><div class="line"> * Poor hash function which always returns 1 to simulate</div><div class="line"> * a Deny of Service attack.</div><div class="line"> */</div><div class="line">struct dos_attack_simulation_hash {</div><div class="line">    std::size_t operator()(int id) const {</div><div class="line">        return 1;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">int main() {</div><div class="line">    /*</div><div class="line">     * Slow due to the hash function, insertions are done in O(n).</div><div class="line">     */</div><div class="line">    tsl::hopscotch_map&lt;int, int, dos_attack_simulation_hash&gt; map;</div><div class="line"></div><div class="line">    auto start = std::chrono::high_resolution_clock::now();</div><div class="line">    for(int i=0; i &lt; 10000; i++) {</div><div class="line">        map.insert({i, 0});</div><div class="line">    }</div><div class="line">    auto end = std::chrono::high_resolution_clock::now();</div><div class="line"></div><div class="line">    // 110 ms</div><div class="line">    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end-start);</div><div class="line">    std::cout &lt;&lt; duration.count() &lt;&lt; &quot; ms&quot; &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    /*</div><div class="line">     * Faster. Even with the poor hash function, insertions end-up to</div><div class="line">     * be O(log n) in average (and O(n) when a rehash occurs).</div><div class="line">     */</div><div class="line">    tsl::bhopscotch_map&lt;int, int, dos_attack_simulation_hash&gt; map_secure;</div><div class="line"></div><div class="line">    start = std::chrono::high_resolution_clock::now();</div><div class="line">    for(int i=0; i &lt; 10000; i++) {</div><div class="line">        map_secure.insert({i, 0});</div><div class="line">    }</div><div class="line">    end = std::chrono::high_resolution_clock::now();</div><div class="line"></div><div class="line">    // 2 ms</div><div class="line">    duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end-start);</div><div class="line">    std::cout &lt;&lt; duration.count() &lt;&lt; &quot; ms&quot; &lt;&lt; std::endl;</div><div class="line">} </div></div><!-- fragment --><h3>License</h3>
<p>The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
